### Install PostgreSQL packages

# make sure an old version of PostgreSQL is absent
#   ignore warnings about using yum instead of rpm;
#   yum can not be used here because it would also erase postgresql11-libs if presented
#   so it would be always "changed"
- name: uninstall old version of PostgreSQL
  shell: rpm -e postgresql-libs
  register: rpm_rc
  changed_when: rpm_rc.rc == 0
  failed_when: false

- name: make sure the minor revision of PostgreSQL
  set_fact:
    pg_rev: '17.7-1PGDG.rhel9'
  when: pg_rev is not defined
- name: extract major version number of PostgreSQL
  set_fact:
    pg_major: "{{ pg_rev | regex_replace('^(\\d*)\\..*', '\\1') }}"
- name: make sure pg_rev format is valid
  fail:
    msg: |
      'pg_rev' format must look like '17.7-1PGDG.rhel9'
      Hint - the format has been changed so that it must contains rhel revision
  when: '"rhel" not in pg_rev'

- name: copy PostgreSQL packages to the node
  copy:
    src="{{ item }}"
    dest="/var/tmp/"
  with_items:
      # the order is significant - as each rpms will be installed in this order
      - postgresql{{ pg_major }}-libs-{{ pg_rev }}.x86_64.rpm
      - postgresql{{ pg_major }}-{{ pg_rev }}.x86_64.rpm
      - postgresql{{ pg_major }}-server-{{ pg_rev }}.x86_64.rpm
      - postgresql{{ pg_major }}-docs-{{ pg_rev }}.x86_64.rpm
      - postgresql{{ pg_major }}-contrib-{{ pg_rev }}.x86_64.rpm
  register: rc_copy

- name: install PostgreSQL packages
  yum:
    name="{{ item.dest | default(item.path) }}"
    update_cache=yes
    disable_gpg_check=true
    state=present
  with_items: "{{ rc_copy.results }}"
  loop_control:
    label: "{{ item.dest | default(item.path) }}" # to suppress too verbose logs

### Setup postgres user's environment
- name: add PATH to postgres user environment
  become: yes
  become_user: postgres
  lineinfile:
    dest="/var/lib/pgsql/.pgsql_profile"
    regexp="^export PATH=/usr/pgsql-{{ pg_major }}/bin:\$PATH"
    line="export PATH=/usr/pgsql-{{ pg_major }}/bin:$PATH"
    create=true
    state=present

- name: add PGDATA to postgres user environment
  become: yes
  become_user: postgres
  lineinfile:
    dest="/var/lib/pgsql/.pgsql_profile"
    regexp="^export PGDATA="
    line="export PGDATA={{ PGDATA }}"
    create=true
    state=present
  
### Prepare DB directories
- file: path="{{ PGDATA }}" state=directory owner=postgres group=postgres mode=0700
- file: path="{{ PGDATA_PREFIX }}/pgwal/pg_wal" state=directory owner=postgres group=postgres mode=0700
- file: path="{{ PGDATA_PREFIX }}/pgarch/arc1" state=directory owner=postgres group=postgres mode=0700

### Initialize DB and configurations on Master node
- block:
### Initialize DB
  - stat: path={{ PGDATA }}/PG_VERSION
    register: db_initialized
  - name: initialize the database
    shell: . /var/lib/pgsql/.bash_profile && initdb -D {{ PGDATA }} -X {{ PGDATA_PREFIX }}/pgwal/pg_wal --encoding=UTF-8 --no-locale --data-checksums
    when: not db_initialized.stat.exists

### Configurations for PostgreSQL server
  - name: configurations of postgresql.conf
    lineinfile:
      dest={{ PGDATA }}/postgresql.conf
      regexp="^{{ item.key }}[ =]"
      line="{{ item.key }} = {{ item.value }}"
    with_items:
      - { key: "listen_addresses", value: "'*'" }
      - { key: "superuser_reserved_connections", value: "10" }
      - { key: "password_encryption", value: "scram-sha-256" }
      - { key: "wal_level", value: "replica" }
      - { key: "synchronous_commit", value: "on" }
      - { key: "archive_mode", value: "always" }
      - { key: "archive_command", value: "'/bin/cp %p {{ PGDATA_PREFIX }}/pgarch/arc1/%f'" }
      - { key: "max_wal_senders", value: "10" }
      - { key: "wal_keep_size", value: "512MB" }
      - { key: "wal_sender_timeout", value: "20s" }
      - { key: "max_replication_slots", value: "10" }
      - { key: "hot_standby", value: "on" }
      - { key: "max_standby_archive_delay", value: "-1" }
      - { key: "max_standby_streaming_delay", value: "-1" }
      - { key: "hot_standby_feedback", value: "on" }
      - { key: "wal_receiver_timeout", value: "20s" }
      - { key: "restart_after_crash", value: "off" }

### create a replication user
  - name: create a replication user
    shell: . /var/lib/pgsql/.bash_profile && {{ item }}
    with_items:
      - pg_ctl -w start
      - psql -c "\du {{ REPUSER }}" | grep {{ REPUSER }} || psql -c "CREATE ROLE {{ REPUSER }} REPLICATION LOGIN PASSWORD '{{ REPPASSWD }}'"
      - pg_ctl stop
    register: repuser_result
    changed_when: '"CREATE ROLE" in repuser_result.stdout'

  - name: configurations of pg_hba.conf
    lineinfile:
      dest={{ PGDATA }}/pg_hba.conf
      line="host replication {{ REPUSER }}  {{ hostvars[item].replication_addr }}/32 scram-sha-256"
    with_items: "{{ ansible_play_hosts }}"

  become: yes
  become_user: postgres
  when: inventory_hostname == ansible_play_hosts[0]
### end block for Master node

# create .pgpass if not exists
# file state=touch can not be usable because it always 'changed'
- stat: path=/var/lib/pgsql/.pgpass
  register: pgpass

- name: create .pgpass with the given permissions
  file: path=/var/lib/pgsql/.pgpass owner=postgres group=postgres mode=0600 state={{ "file" if pgpass.stat.exists else "touch" }}

- name: add .pgpass for replication users of VIP
  lineinfile:
    dest=/var/lib/pgsql/.pgpass
    line="{{ ipaddr_replication.ip }}:{{ PGPORT }}:replication:{{ REPUSER }}:{{ REPPASSWD }}"

- name: add .pgpass for replication users of the nodes excluding myself
  lineinfile:
    dest=/var/lib/pgsql/.pgpass
    line="{{ hostvars[item].replication_addr }}:{{ PGPORT }}:replication:{{ REPUSER }}:{{ REPPASSWD }}"
  with_items: "{{ ansible_play_hosts }}"
  when: item != inventory_hostname


### allow communitation ports if firewalld is in use
- name: check if firewalld is enabled
  command: firewall-cmd --state
  changed_when: false
  failed_when: false
  register: firewalld_state

- name: allow PostgreSQL/replication port through firewalld (permanent)
  command: firewall-cmd --permanent --add-service=postgresql
  register: result
  changed_when: '"ALREADY_ENABLED" not in result.stderr'
  when: firewalld_state.rc == 0

- name: allow PostgreSQL/replication port through firewalld (runtime)
  command: firewall-cmd --add-service=postgresql
  register: result
  changed_when: '"ALREADY_ENABLED" not in result.stderr'
  when: firewalld_state.rc == 0
